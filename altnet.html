<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Altruism Network Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: Arial, sans-serif; }
    #info { position: absolute; color: white; padding: 10px; bottom: 10px; left: 10px; }
    #debug { position: absolute; color: white; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; }
  </style>
</head>
<body>
  <div id="info">Altruism Network Simulation - Drag to rotate, scroll to zoom</div>
  <div id="debug">Loading simulation...</div>

  <!-- Import libraries from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

  <script>
    // Debug helper
    function log(msg) {
      console.log(msg);
      document.getElementById('debug').innerHTML += '<br>' + msg;
    }
    
    log('Initializing...');
    
    // Global variables
    let scene, camera, renderer, controls;
    let agents = [];
    let connections = [];
    
    // Parameters
    const params = {
      numAgents: 20,
      altruismStrength: 1.0,
      incomeInequality: 1.0,
      runSimulation: true,
      showConnections: true,
      
      reinitialize: function() {
        clearScene();
        initializeAgents();
      }
    };
    
    // Setup scene
    function init() {
      log('Setting up scene');
      
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111133);
      
      // Setup camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 40);
      
      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add orbit controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 1, 1);
      scene.add(directionalLight);
      
      // Setup GUI
      setupGUI();
      
      // Initialize agents
      initializeAgents();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      log('Scene setup complete');
    }
    
    // Create GUI controls
    function setupGUI() {
      const gui = new dat.GUI();
      
      gui.add(params, 'numAgents', 5, 50, 1).name('Number of Agents');
      gui.add(params, 'altruismStrength', 0.1, 2.0, 0.1).name('Altruism Strength');
      gui.add(params, 'incomeInequality', 0.1, 3.0, 0.1).name('Income Inequality');
      gui.add(params, 'showConnections').name('Show Connections');
      gui.add(params, 'runSimulation').name('Run Simulation');
      gui.add(params, 'reinitialize').name('Reinitialize');
    }
    
    // Handle window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Generate agent incomes with controlled inequality
    function generateIncomes(count, inequalityFactor) {
      const incomes = [];
      
      if (inequalityFactor <= 1) {
        // Close to uniform distribution
        for (let i = 0; i < count; i++) {
          incomes.push(2 + Math.random() * 8); // range [2-10]
        }
      } else {
        // Power law distribution
        const exponent = 1 + inequalityFactor * 0.5;
        
        for (let i = 0; i < count; i++) {
          const r = Math.random();
          const x = Math.pow(r, -1/exponent);
          incomes.push(1 + x * 19);
        }
      }
      
      return incomes;
    }
    
    // Create agents and connections
    function initializeAgents() {
      log('Creating agents...');
      
      // Generate incomes
      const incomes = generateIncomes(params.numAgents, params.incomeInequality);
      
      // Create agents
      for (let i = 0; i < params.numAgents; i++) {
        // Position agents in a circle
        const angle = (i / params.numAgents) * Math.PI * 2;
        const radius = 15;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = (Math.random() - 0.5) * 5;
        
        // Create agent geometry
        const geometry = new THREE.SphereGeometry(1, 16, 16);
        
        // Color based on income
        const normalizedIncome = (incomes[i] - 1) / 19; // normalize to [0,1]
        const color = new THREE.Color();
        color.setHSL(0.7 - normalizedIncome * 0.5, 0.8, 0.5 + normalizedIncome * 0.5);
        
        const material = new THREE.MeshPhongMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        scene.add(mesh);
        
        // Create text to show income
        const textCanvas = document.createElement('canvas');
        textCanvas.width = 128;
        textCanvas.height = 128;
        const ctx = textCanvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.font = '50px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(incomes[i].toFixed(1), 64, 64);
        
        const textTexture = new THREE.CanvasTexture(textCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: textTexture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(2, 1, 1);
        sprite.position.set(0, 1.5, 0);
        mesh.add(sprite);
        
        // Store agent data
        agents.push({
          mesh: mesh,
          income: incomes[i],
          consumption: incomes[i],
          utility: Math.log(incomes[i]), // simple log utility
          position: new THREE.Vector3(x, y, z)
        });
      }
      
      log('Creating connections...');
      
      // Create altruistic connections between agents
      for (let i = 0; i < agents.length; i++) {
        // Connect to neighbors with some probability
        for (let j = 0; j < agents.length; j++) {
          if (i !== j) {
            const distance = agents[i].position.distanceTo(agents[j].position);
            // Higher probability for closer agents
            const probability = 0.5 * (1 / (1 + distance * 0.05));
            
            if (Math.random() < probability) {
              createConnection(i, j);
            }
          }
        }
      }
      
      log('Initialization complete: ' + agents.length + ' agents, ' + connections.length + ' connections');
    }
    
    // Create a connection between two agents
    function createConnection(i, j) {
      const points = [
        agents[i].position,
        agents[j].position
      ];
      
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x88aaff,
        transparent: true,
        opacity: 0.6
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      
      connections.push({
        from: i,
        to: j,
        strength: params.altruismStrength * (0.8 + Math.random() * 0.4),
        object: line
      });
    }
    
    // Clear scene
    function clearScene() {
      log('Clearing scene');
      
      // Remove all agents and connections
      agents.forEach(agent => {
        scene.remove(agent.mesh);
      });
      
      connections.forEach(connection => {
        scene.remove(connection.object);
      });
      
      agents = [];
      connections = [];
    }
    
    // Simulate transfers
    function simulateTransfers() {
      if (!params.runSimulation) return;
      
      // Reset consumptions to incomes
      agents.forEach(agent => {
        agent.consumption = agent.income;
      });
      
      // Calculate transfers
      for (let iter = 0; iter < 5; iter++) {
        connections.forEach(connection => {
          const giver = agents[connection.from];
          const receiver = agents[connection.to];
          
          // Simple transfer logic: richer gives to poorer based on connection strength
          if (giver.consumption > receiver.consumption) {
            const transferAmount = (giver.consumption - receiver.consumption) * 0.05 * connection.strength;
            
            if (transferAmount > 0.1 && transferAmount < giver.consumption * 0.5) {
              giver.consumption -= transferAmount;
              receiver.consumption += transferAmount;
            }
          }
        });
      }
      
      // Update agent appearances based on consumption
      agents.forEach(agent => {
        // Update utility
        agent.utility = Math.log(agent.consumption);
        
        // Update color based on consumption
        const normalizedConsumption = (agent.consumption - 1) / 19;
        const color = new THREE.Color();
        color.setHSL(0.7 - normalizedConsumption * 0.5, 0.8, 0.5 + normalizedConsumption * 0.5);
        agent.mesh.material.color = color;
        
        // Update size based on consumption/income ratio
        const scale = 0.8 + (agent.consumption / agent.income) * 0.4;
        agent.mesh.scale.set(scale, scale, scale);
      });
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Simulate transfers
      simulateTransfers();
      
      // Toggle connection visibility
      connections.forEach(conn => {
        conn.object.visible = params.showConnections;
      });
      
      // Render
      renderer.render(scene, camera);
      controls.update();
    }
    
    // Start everything
    init();
    animate();
  </script>
</body>
</html>
