<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Altruism Network Simulation</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: #000; 
      font-family: Arial, sans-serif; 
      color: #fff;
    }
    #info { 
      position: absolute; 
      bottom: 10px; 
      left: 10px; 
      color: white; 
      z-index: 100; 
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #simulationStats {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      max-width: 300px;
    }
    #simulationControls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 1000;
      max-height: 90vh;
      overflow-y: auto;
    }
    #simulationControls h3 {
      margin-top: 10px;
      margin-bottom: 5px;
      color: #aaddff;
    }
    #simulationControls button {
      background: #4a5fa3;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 5px;
      border-radius: 3px;
      cursor: pointer;
    }
    #simulationControls button:hover {
      background: #677bc4;
    }
    #simulationControls button.active {
      background: #ff77aa;
    }
    .control-group {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    #utilityGraph {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
    canvas {
      display: block;
    }
    .emoji-face {
      position: absolute;
      font-size: 24px;
      color: white;
      text-shadow: 0 0 3px black;
      opacity: 0.9;
    }
    label {
      display: block;
      margin-top: 5px;
      margin-bottom: 3px;
    }
    input[type="range"] {
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="info">Dynamic Altruism Network Simulation — drag to rotate, scroll to zoom</div>
  
  <div id="simulationStats">
    <h3>Simulation Statistics</h3>
    <div id="iterationCount">Iteration: 0</div>
    <div id="avgUtility">Average Utility: 0</div>
    <div id="transferCount">Transfers: 0</div>
    <div id="inequalityMeasure">Consumption Gini: 0</div>
  </div>
  
  <div id="simulationControls">
    <h3>Simulation Controls</h3>
    <div class="control-group">
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
      <button id="shockBtn">Add Income Shock</button>
      
      <label for="simSpeedSlider">Simulation Speed:</label>
      <input type="range" id="simSpeedSlider" min="1" max="20" value="5">
      
      <label for="altruismStrength">Altruism Strength:</label>
      <input type="range" id="altruismStrength" min="0.1" max="2" step="0.1" value="1">
      
      <label for="incomeInequalitySlider">Income Inequality:</label>
      <input type="range" id="incomeInequalitySlider" min="0.1" max="5" step="0.1" value="3">
      
      <label for="agentCountSlider">Number of Agents:</label>
      <input type="range" id="agentCountSlider" min="10" max="50" step="1" value="30">
    </div>
    
    <h3>Display Options</h3>
    <div class="control-group">
      <label for="nodeSizeSlider">Node Size:</label>
      <input type="range" id="nodeSizeSlider" min="0.5" max="3" step="0.1" value="1">
      
      <label for="connectionWidthSlider">Connection Width:</label>
      <input type="range" id="connectionWidthSlider" min="0.5" max="3" step="0.1" value="1">
      
      <div>
        <label for="showEmojisToggle">Show Faces:</label>
        <input type="checkbox" id="showEmojisToggle" checked>
      </div>
      
      <div>
        <label for="showTransfersToggle">Show Transfers:</label>
        <input type="checkbox" id="showTransfersToggle" checked>
      </div>
      
      <div>
        <label for="showConnectionsToggle">Show Connections:</label>
        <input type="checkbox" id="showConnectionsToggle" checked>
      </div>
    </div>
    
    <h3>Visualization Mode</h3>
    <div class="control-group">
      <button id="colorByUtilityBtn" class="active">Color by Utility</button>
      <button id="colorByIncomeBtn">Color by Income</button>
      <button id="colorByTransfersBtn">Color by Transfers</button>
    </div>
    
    <h3>Network Layout</h3>
    <div class="control-group">
      <button id="layoutCircleBtn" class="active">Circle</button>
      <button id="layoutGridBtn">Grid</button>
      <button id="layoutRandomBtn">Random</button>
    </div>
  </div>
  
  <div id="utilityGraph">
    <canvas id="graphCanvas" width="300" height="150"></canvas>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Global variables
    let scene, camera, renderer, controls;
    let agents = [];
    let connections = [];
    let activeTransfers = [];
    let utilityHistory = [];
    let inequalityHistory = [];
    let transferParticles = [];
    
    // Display parameters
    let displayParams = {
      nodeSize: 1.0,
      connectionWidth: 1.0,
      showEmojis: true,
      showTransfers: true,
      showConnections: true,
      colorMode: 'utility', // 'utility', 'income', 'transfers'
      layout: 'circle' // 'circle', 'grid', 'random'
    };
    
    // Simulation parameters
    let params = {
      numAgents: 30,
      altruismStrength: 1.0,
      incomeInequality: 3.0, // Starting with higher inequality to show more variation
      simulationSpeed: 5,
      iterationCount: 0,
      transferCount: 0,
      isPaused: false
    };
    
    // Colors for different utility levels
    const highUtilityColor = new THREE.Color(0xff77ff); // Pink - happy
    const medUtilityColor = new THREE.Color(0xffff77);  // Yellow - neutral
    const lowUtilityColor = new THREE.Color(0x77ffff);  // Blue - sad
    
    // For income coloring
    const lowIncomeColor = new THREE.Color(0x3333ff);   // Blue - poor
    const highIncomeColor = new THREE.Color(0xff3333);  // Red - rich
    
    // For transfer coloring
    const lowTransferColor = new THREE.Color(0x33ff33); // Green - low activity
    const highTransferColor = new THREE.Color(0xffaa33); // Orange - high activity
    
    // Initialize scene
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111133);
      
      // Setup camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 50);
      
      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 1, 1);
      scene.add(directionalLight);
      
      // Initialize UI elements
      setupUIControls();
      
      // Create agents and connections
      createAgentsAndConnections();
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Setup UI controls
    function setupUIControls() {
      // Pause button
      document.getElementById('pauseBtn').addEventListener('click', () => {
        params.isPaused = !params.isPaused;
        document.getElementById('pauseBtn').textContent = params.isPaused ? 'Resume' : 'Pause';
      });
      
      // Reset button
      document.getElementById('resetBtn').addEventListener('click', () => {
        resetSimulation();
      });
      
      // Add income shock
      document.getElementById('shockBtn').addEventListener('click', () => {
        addIncomeShock();
      });
      
      // Speed slider
      document.getElementById('simSpeedSlider').addEventListener('input', (e) => {
        params.simulationSpeed = parseInt(e.target.value);
      });
      
      // Altruism strength slider
      document.getElementById('altruismStrength').addEventListener('input', (e) => {
        params.altruismStrength = parseFloat(e.target.value);
        updateConnectionStrengths();
      });
      
      // Income inequality slider
      document.getElementById('incomeInequalitySlider').addEventListener('input', (e) => {
        params.incomeInequality = parseFloat(e.target.value);
      });
      
      // Agent count slider
      document.getElementById('agentCountSlider').addEventListener('input', (e) => {
        params.numAgents = parseInt(e.target.value);
      });
      
      // Node size slider
      document.getElementById('nodeSizeSlider').addEventListener('input', (e) => {
        displayParams.nodeSize = parseFloat(e.target.value);
        updateAgentSizes();
      });
      
      // Connection width slider
      document.getElementById('connectionWidthSlider').addEventListener('input', (e) => {
        displayParams.connectionWidth = parseFloat(e.target.value);
        updateConnectionWidths();
      });
      
      // Show emojis toggle
      document.getElementById('showEmojisToggle').addEventListener('change', (e) => {
        displayParams.showEmojis = e.target.checked;
        updateEmojisVisibility();
      });
      
      // Show transfers toggle
      document.getElementById('showTransfersToggle').addEventListener('change', (e) => {
        displayParams.showTransfers = e.target.checked;
      });
      
      // Show connections toggle
      document.getElementById('showConnectionsToggle').addEventListener('change', (e) => {
        displayParams.showConnections = e.target.checked;
        updateConnectionsVisibility();
      });
      
      // Color mode buttons
      document.getElementById('colorByUtilityBtn').addEventListener('click', () => {
        displayParams.colorMode = 'utility';
        setActiveButton('colorByUtilityBtn', ['colorByIncomeBtn', 'colorByTransfersBtn']);
        updateAgentColors();
      });
      
      document.getElementById('colorByIncomeBtn').addEventListener('click', () => {
        displayParams.colorMode = 'income';
        setActiveButton('colorByIncomeBtn', ['colorByUtilityBtn', 'colorByTransfersBtn']);
        updateAgentColors();
      });
      
      document.getElementById('colorByTransfersBtn').addEventListener('click', () => {
        displayParams.colorMode = 'transfers';
        setActiveButton('colorByTransfersBtn', ['colorByUtilityBtn', 'colorByIncomeBtn']);
        updateAgentColors();
      });
      
      // Layout buttons
      document.getElementById('layoutCircleBtn').addEventListener('click', () => {
        displayParams.layout = 'circle';
        setActiveButton('layoutCircleBtn', ['layoutGridBtn', 'layoutRandomBtn']);
        repositionAgents();
      });
      
      document.getElementById('layoutGridBtn').addEventListener('click', () => {
        displayParams.layout = 'grid';
        setActiveButton('layoutGridBtn', ['layoutCircleBtn', 'layoutRandomBtn']);
        repositionAgents();
      });
      
      document.getElementById('layoutRandomBtn').addEventListener('click', () => {
        displayParams.layout = 'random';
        setActiveButton('layoutRandomBtn', ['layoutCircleBtn', 'layoutGridBtn']);
        repositionAgents();
      });
    }
    
    // Helper to set active button
    function setActiveButton(activeId, inactiveIds) {
      document.getElementById(activeId).classList.add('active');
      inactiveIds.forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
    }
    
    // Update agent sizes
    function updateAgentSizes() {
      agents.forEach(agent => {
        // Base size scaled by display parameter
        let baseScale = displayParams.nodeSize;
        
        // Additional scaling based on utility or other factors
        let utilityScale = 0.8 + (agent.utility / 2) * 0.4; // Utility is typically 0-2
        
        // Apply scale
        let finalScale = baseScale * utilityScale;
        agent.mesh.scale.set(finalScale, finalScale, finalScale);
      });
    }
    
    // Update connection widths
    function updateConnectionWidths() {
      connections.forEach(conn => {
        // Each connection's line has a material we can update
        if (conn.object && conn.object.material) {
          // Base width scaled by display parameter
          let scaledWidth = displayParams.connectionWidth * 2; // Multiplier to make it visible
          conn.object.material.linewidth = scaledWidth; // Note: this has limited browser support
          
          // We can also update the opacity to make it more visible
          conn.object.material.opacity = 0.4 * displayParams.connectionWidth;
        }
      });
    }
    
    // Update emojis visibility
    function updateEmojisVisibility() {
      agents.forEach(agent => {
        if (agent.emojiElement) {
          agent.emojiElement.style.display = displayParams.showEmojis ? 'block' : 'none';
        }
      });
    }
    
    // Update connections visibility
    function updateConnectionsVisibility() {
      connections.forEach(conn => {
        if (conn.object) {
          conn.object.visible = displayParams.showConnections;
        }
      });
    }
    
    // Reposition agents based on layout
    function repositionAgents() {
      if (displayParams.layout === 'circle') {
        agents.forEach((agent, i) => {
          const angle = (i / agents.length) * Math.PI * 2;
          const radius = 15 + (Math.random() - 0.5) * 5;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          const z = (Math.random() - 0.5) * 5;
          
          // Animate position change
          animatePosition(agent, new THREE.Vector3(x, y, z));
        });
      } 
      else if (displayParams.layout === 'grid') {
        const gridSize = Math.ceil(Math.sqrt(agents.length));
        const spacing = 30 / gridSize;
        
        agents.forEach((agent, i) => {
          const row = Math.floor(i / gridSize);
          const col = i % gridSize;
          
          const x = (col - gridSize/2 + 0.5) * spacing;
          const y = (row - gridSize/2 + 0.5) * spacing;
          const z = (Math.random() - 0.5) * 3;
          
          // Animate position change
          animatePosition(agent, new THREE.Vector3(x, y, z));
        });
      }
      else if (displayParams.layout === 'random') {
        agents.forEach(agent => {
          const x = (Math.random() - 0.5) * 30;
          const y = (Math.random() - 0.5) * 30;
          const z = (Math.random() - 0.5) * 10;
          
          // Animate position change
          animatePosition(agent, new THREE.Vector3(x, y, z));
        });
      }
      
      // Update connections after a brief delay to allow agent positions to update
      setTimeout(updateConnections, 1000);
    }
    
    // Animate position change
    function animatePosition(agent, newPosition) {
      const originalPosition = agent.position.clone();
      const startTime = Date.now();
      const duration = 1000; // Animation duration in ms
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease in-out function for smoother animation
        const easedProgress = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // Interpolate position
        const currentPosition = new THREE.Vector3().lerpVectors(
          originalPosition,
          newPosition,
          easedProgress
        );
        
        // Update position
        agent.position.copy(currentPosition);
        agent.mesh.position.copy(currentPosition);
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      }
      
      animate();
    }
    
    // Update connections after agent positions change
    function updateConnections() {
      connections.forEach(conn => {
        // Get updated positions
        const fromPos = agents[conn.from].position;
        const toPos = agents[conn.to].position;
        
        // Update connection geometry
        if (conn.object) {
          scene.remove(conn.object);
          
          // Create new connection with updated positions
          const points = [fromPos, toPos];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const material = new THREE.LineBasicMaterial({
            color: 0x88aaff,
            transparent: true,
            opacity: 0.4 * displayParams.connectionWidth
          });
          
          const line = new THREE.Line(geometry, material);
          scene.add(line);
          
          // Update connection object
          conn.object = line;
        }
      });
    }
    
    // Update agent colors based on selected mode
    function updateAgentColors() {
      agents.forEach(agent => {
        let color;
        
        if (displayParams.colorMode === 'utility') {
          // Color based on utility
          const normalizedUtility = Math.min(1, agent.utility / 2);
          
          if (normalizedUtility > 0.66) {
            color = highUtilityColor;
          } else if (normalizedUtility > 0.33) {
            color = medUtilityColor;
          } else {
            color = lowUtilityColor;
          }
          
          // Update emoji face
          if (agent.emojiElement) {
            agent.emojiElement.textContent = normalizedUtility > 0.66 ? '😊' : normalizedUtility > 0.33 ? '😐' : '😟';
          }
        } 
        else if (displayParams.colorMode === 'income') {
          // Color based on income
          // Find max income for normalization
          const maxIncome = Math.max(...agents.map(a => a.income));
          const normalizedIncome = agent.income / maxIncome;
          
          // Interpolate between low and high income colors
          color = lowIncomeColor.clone().lerp(highIncomeColor, normalizedIncome);
          
          // Update emoji to show income level
          if (agent.emojiElement) {
            agent.emojiElement.textContent = normalizedIncome > 0.66 ? '💰' : normalizedIncome > 0.33 ? '💼' : '👝';
          }
        } 
        else if (displayParams.colorMode === 'transfers') {
          // Color based on transfer activity
          // Normalize by max transfer count
          const maxTransfers = Math.max(1, ...agents.map(a => a.transferCount || 0));
          const normalizedTransfers = (agent.transferCount || 0) / maxTransfers;
          
          // Interpolate between low and high transfer colors
          color = lowTransferColor.clone().lerp(highTransferColor, normalizedTransfers);
          
          // Update emoji to show transfer activity
          if (agent.emojiElement) {
            agent.emojiElement.textContent = normalizedTransfers > 0.66 ? '🔄' : normalizedTransfers > 0.33 ? '↔️' : '⏹️';
          }
        }
        
        // Apply color
        if (agent.mesh && agent.mesh.material) {
          agent.mesh.material.color.copy(color);
        }
      });
    }
    
    // Update connection strengths when altruism parameter changes
    function updateConnectionStrengths() {
      connections.forEach(conn => {
        // Keep the random component but update the base strength
        conn.strength = params.altruismStrength * conn.randomFactor;
      });
    }
    
    // Generate agent incomes with controlled inequality
    function generateIncomes(count, inequalityFactor) {
      const incomes = [];
      
      if (inequalityFactor <= 1) {
        // Close to uniform distribution
        for (let i = 0; i < count; i++) {
          incomes.push(2 + Math.random() * 8); // range [2-10]
        }
      } else {
        // Power law distribution
        const exponent = 1 + inequalityFactor * 0.5;
        
        for (let i = 0; i < count; i++) {
          const r = Math.random();
          const x = Math.pow(r, -1/exponent);
          incomes.push(1 + x * 19);
        }
      }
      
      return incomes;
    }
    
    // Calculate utility given a consumption level
    function calculateUtility(consumption) {
      // CARA utility function: (1 - e^(-α*c))/α
      const alpha = 0.5;
      return (1 - Math.exp(-alpha * consumption)) / alpha;
    }
    
    // Calculate marginal utility
    function calculateMarginalUtility(consumption) {
      const alpha = 0.5;
      return Math.exp(-alpha * consumption);
    }
    
    // Create agents and connections
    function createAgentsAndConnections() {
      // Clear existing objects
      clearScene();
      
      // Generate incomes
      const incomes = generateIncomes(params.numAgents, params.incomeInequality);
      
      // Create agents
      for (let i = 0; i < params.numAgents; i++) {
        let position;
        
        if (displayParams.layout === 'circle') {
          // Position agents in a circle with some randomness
          const angle = (i / params.numAgents) * Math.PI * 2;
          const radius = 15 + (Math.random() - 0.5) * 5;
          position = new THREE.Vector3(
            Math.cos(angle) * radius,
            Math.sin(angle) * radius,
            (Math.random() - 0.5) * 5
          );
        }
        else if (displayParams.layout === 'grid') {
          // Position agents in a grid
          const gridSize = Math.ceil(Math.sqrt(params.numAgents));
          const spacing = 30 / gridSize;
          
          const row = Math.floor(i / gridSize);
          const col = i % gridSize;
          
          position = new THREE.Vector3(
            (col - gridSize/2 + 0.5) * spacing,
            (row - gridSize/2 + 0.5) * spacing,
            (Math.random() - 0.5) * 3
          );
        }
        else { // Random layout
          position = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 10
          );
        }
        
        // Create agent geometry
        const geometry = new THREE.SphereGeometry(1, 16, 16);
        
        // Calculate initial utility and color
        const consumption = incomes[i];
        const utility = calculateUtility(consumption);
        const normalizedUtility = Math.min(1, utility / 2);
        
        let color;
        if (normalizedUtility > 0.66) {
          color = highUtilityColor;
        } else if (normalizedUtility > 0.33) {
          color = medUtilityColor;
        } else {
          color = lowUtilityColor;
        }
        
        const material = new THREE.MeshPhongMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(position);
        
        // Apply base size scaling
        const baseScale = displayParams.nodeSize;
        const utilityScale = 0.8 + normalizedUtility * 0.4;
        const finalScale = baseScale * utilityScale;
        mesh.scale.set(finalScale, finalScale, finalScale);
        
        scene.add(mesh);
        
        // Create emoji element
        const emojiElement = document.createElement('div');
        emojiElement.className = 'emoji-face';
        emojiElement.textContent = normalizedUtility > 0.66 ? '😊' : normalizedUtility > 0.33 ? '😐' : '😟';
        emojiElement.style.display = displayParams.showEmojis ? 'block' : 'none';
        document.body.appendChild(emojiElement);
        
        // Store agent data
        agents.push({
          mesh: mesh,
          income: incomes[i],
          consumption: consumption,
          utility: utility,
          position: position,
          emojiElement: emojiElement,
          lastUpdated: 0,
          transferCount: 0 // Track how many transfers this agent is involved in
        });
      }
      
      // Create connections between agents
      createConnections();
      
      // Initialize history arrays
      utilityHistory = [];
      inequalityHistory = [];
      
      // Reset stats
      params.iterationCount = 0;
      params.transferCount = 0;
      
      updateStats();
    }
    
    // Create connections between agents
    function createConnections() {
      connections = [];
      
      for (let i = 0; i < agents.length; i++) {
        // Connect to neighbors with some probability
        for (let j = 0; j < agents.length; j++) {
          if (i !== j) {
            const distance = agents[i].position.distanceTo(agents[j].position);
            // Higher probability for closer agents
            const probability = 0.3 * (1 / (1 + distance * 0.05));
            
            if (Math.random() < probability) {
              createConnection(i, j);
            }
          }
        }
        
        // Ensure each agent has at least one connection
        if (!connections.some(c => c.from === i || c.to === i)) {
          // Connect to the closest agent
          let closestIdx = -1;
          let minDist = Infinity;
          
          for (let j = 0; j < agents.length; j++) {
            if (i !== j) {
              const distance = agents[i].position.distanceTo(agents[j].position);
              if (distance < minDist) {
                minDist = distance;
                closestIdx = j;
              }
            }
          }
          
          if (closestIdx >= 0) {
            createConnection(i, closestIdx);
          }
        }
      }
    }
    
    // Create a connection between two agents
    function createConnection(i, j) {
      const points = [
        agents[i].position,
        agents[j].position
      ];
      
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x88aaff,
        transparent: true,
        opacity: 0.4 * displayParams.connectionWidth
      });
      
      const line = new THREE.Line(geometry, material);
      line.visible = displayParams.showConnections;
      scene.add(line);
      
      // Random factor for connection strength
      const randomFactor = 0.8 + Math.random() * 0.4;
      
      connections.push({
        from: i,
        to: j,
        strength: params.altruismStrength * randomFactor,
        randomFactor: randomFactor, // Store for updates
        object: line
      });
    }
    
    // Create a transfer visualization
    function createTransferVisualization(fromAgent, toAgent, amount) {
      if (!displayParams.showTransfers) return null;
      
      // Create a small sphere representing the transfer
      const geometry = new THREE.SphereGeometry(0.2, 8, 8);
      const material = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        transparent: true,
        opacity: 0.8
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      
      // Start at the giving agent
      mesh.position.copy(fromAgent.position);
      scene.add(mesh);
      
      // Store the transfer particle data
      transferParticles.push({
        mesh: mesh,
        from: fromAgent,
        to: toAgent,
        amount: amount,
        progress: 0,
        speed: 0.02 + Math.random() * 0.02
      });
      
      return mesh;
    }
    
    // Update transfer particles
    function updateTransferParticles() {
      // Skip if transfers are hidden
      if (!displayParams.showTransfers) {
        transferParticles.forEach(particle => {
          if (particle.mesh) particle.mesh.visible = false;
        });
        return;
      }
      
      // Update existing particles
      for (let i = transferParticles.length - 1; i >= 0; i--) {
        const particle = transferParticles[i];
        
        // Show particles
        if (particle.mesh) particle.mesh.visible = true;
        
        // Update progress
        particle.progress += particle.speed;
        
        if (particle.progress >= 1) {
          // Remove completed particles
          scene.remove(particle.mesh);
          transferParticles.splice(i, 1);
        } else {
          // Interpolate position
          const newPos = new THREE.Vector3().lerpVectors(
            particle.from.position,
            particle.to.position,
            particle.progress
          );
          
          // Add a small arc to the path
          const mid = new THREE.Vector3().lerpVectors(
            particle.from.position,
            particle.to.position,
            0.5
          );
          
          const up = new THREE.Vector3(0, 0, 1);
          const dir = new THREE.Vector3().subVectors(particle.to.position, particle.from.position);
          if (Math.abs(dir.dot(up)) > 0.9) up.set(1, 0, 0);
          
          const arcHeight = particle.from.position.distanceTo(particle.to.position) * 0.2;
          const normal = new THREE.Vector3().crossVectors(dir, up).normalize();
          
          // Parabolic arc
          const arcOffset = Math.sin(particle.progress * Math.PI) * arcHeight;
          newPos.addScaledVector(normal, arcOffset);
          
          particle.mesh.position.copy(newPos);
          
          // Scale based on amount
          const scale = 0.2 + particle.amount * 0.05;
          particle.mesh.scale.set(scale, scale, scale);
          
          // Pulse effect
          const pulse = 0.8 + 0.2 * Math.sin(particle.progress * Math.PI * 4);
          particle.mesh.scale.multiplyScalar(pulse);
        }
      }
    }
    
    // Clear scene
    function clearScene() {
      // Remove agents
      agents.forEach(agent => {
        scene.remove(agent.mesh);
        if (agent.emojiElement) {
          document.body.removeChild(agent.emojiElement);
        }
      });
      
      // Remove connections
      connections.forEach(connection => {
        scene.remove(connection.object);
      });
      
      // Remove transfer particles
      transferParticles.forEach(particle => {
        scene.remove(particle.mesh);
      });
      
      agents = [];
      connections = [];
      activeTransfers = [];
      transferParticles = [];
    }
    
    // Reset simulation
    function resetSimulation() {
      createAgentsAndConnections();
    }
    
    // Add an income shock to the system
    function addIncomeShock() {
      // Shock multiple agents for more dramatic effect
      const shockCount = Math.max(1, Math.floor(agents.length * 0.1)); // Shock about 10% of agents
      
      for (let shockIndex = 0; shockIndex < shockCount; shockIndex++) {
        // Choose target
        let targetIdx;
        const shockType = Math.random();
        
        if (shockType < 0.5) {
          // Random agent
          targetIdx = Math.floor(Math.random() * agents.length);
        } else {
          // Find the richest agent
          let maxIncome = -Infinity;
          let richestIdx = 0;
          
          for (let i = 0; i < agents.length; i++) {
            if (agents[i].income > maxIncome) {
              maxIncome = agents[i].income;
              richestIdx = i;
            }
          }
          
          targetIdx = richestIdx;
        }
        
        // Apply shock - either positive or negative
        const direction = Math.random() < 0.7 ? 1 : -1; // 70% chance of positive shock
        const magnitude = agents[targetIdx].income * (0.3 + Math.random() * 0.5); // 30-80% change
        
        // Apply the shock
        agents[targetIdx].income += direction * magnitude;
        agents[targetIdx].income = Math.max(1, agents[targetIdx].income); // Ensure minimum income
        
        // Update consumption as well (immediate effect)
        agents[targetIdx].consumption += direction * magnitude;
        agents[targetIdx].consumption = Math.max(1, agents[targetIdx].consumption);
        
        // Update utility
        agents[targetIdx].utility = calculateUtility(agents[targetIdx].consumption);
        
        // Update appearance
        updateAgentAppearance(agents[targetIdx]);
        
        // Visual indication of the shock
        const agent = agents[targetIdx];
        
        // Briefly make the agent larger
        const originalScale = agent.mesh.scale.x;
        agent.mesh.scale.set(originalScale * 2, originalScale * 2, originalScale * 2);
        
        // Animate back to normal size
        setTimeout(() => {
          agent.mesh.scale.set(originalScale, originalScale, originalScale);
        }, 500);
        
        // Show a message
        const shockMsg = document.createElement('div');
        shockMsg.style.position = 'absolute';
        shockMsg.style.color = direction > 0 ? 'lime' : 'red';
        shockMsg.style.fontSize = '16px';
        shockMsg.style.fontWeight = 'bold';
        shockMsg.style.textShadow = '0 0 3px black';
        shockMsg.textContent = direction > 0 ? '+' + magnitude.toFixed(1) : magnitude.toFixed(1);
        
        // Position near the agent
        const screenPos = toScreenPosition(agent.mesh, camera, renderer);
        shockMsg.style.left = screenPos.x + 'px';
        shockMsg.style.top = (screenPos.y - 30) + 'px';
        
        document.body.appendChild(shockMsg);
        
        // Remove after animation
        setTimeout(() => {
          shockMsg.style.transition = 'opacity 1s';
          shockMsg.style.opacity = '0';
        }, 1000);
        
        setTimeout(() => {
          document.body.removeChild(shockMsg);
        }, 2000);
      }
      
      // Update stats
      updateStats();
      
      // Update colors if needed
      updateAgentColors();
    }
    
    // Calculate Gini coefficient (inequality measure)
    function calculateGini(values) {
      // Sort values in ascending order
      const sortedValues = [...values].sort((a, b) => a - b);
      const n = sortedValues.length;
      
      if (n === 0) return 0;
      
      let sumOfAbsoluteDifferences = 0;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          sumOfAbsoluteDifferences += Math.abs(sortedValues[i] - sortedValues[j]);
        }
      }
      
      // Gini formula
      return sumOfAbsoluteDifferences / (2 * n * n * sortedValues.reduce((a, b) => a + b, 0) / n);
    }
    
    // Update simulation statistics
    function updateStats() {
      // Calculate average utility
      let totalUtility = 0;
      for (const agent of agents) {
        totalUtility += agent.utility;
      }
      const avgUtility = totalUtility / agents.length;
      
      // Calculate consumption inequality (Gini coefficient)
      const consumptions = agents.map(a => a.consumption);
      const giniCoefficient = calculateGini(consumptions);
      
      // Update history arrays
      utilityHistory.push(avgUtility);
      inequalityHistory.push(giniCoefficient);
      
      // Limit history length
      const maxHistory = 100;
      if (utilityHistory.length > maxHistory) {
        utilityHistory.shift();
        inequalityHistory.shift();
      }
      
      // Update UI
      document.getElementById('iterationCount').textContent = `Iteration: ${params.iterationCount}`;
      document.getElementById('avgUtility').textContent = `Average Utility: ${avgUtility.toFixed(3)}`;
      document.getElementById('transferCount').textContent = `Transfers: ${params.transferCount}`;
      document.getElementById('inequalityMeasure').textContent = `Consumption Gini: ${giniCoefficient.toFixed(3)}`;
      
      // Draw graph
      drawUtilityGraph();
    }
    
    // Draw utility graph
    function drawUtilityGraph() {
      const canvas = document.getElementById('graphCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, width, height);
      
      // Draw grid lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;
      
      // Horizontal grid lines
      for (let i = 0; i <= 5; i++) {
        const y = height - (i / 5) * height;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // Vertical grid lines
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      // No data to draw
      if (utilityHistory.length < 2) return;
      
      // Find max utility for scaling
      const maxUtility = Math.max(...utilityHistory, 2);
      
      // Draw utility history
      ctx.strokeStyle = 'rgba(255, 119, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < utilityHistory.length; i++) {
        const x = (i / (utilityHistory.length - 1)) * width;
        const y = height - (utilityHistory[i] / maxUtility) * height;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      
      // Draw inequality history
      ctx.strokeStyle = 'rgba(119, 255, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < inequalityHistory.length; i++) {
        const x = (i / (inequalityHistory.length - 1)) * width;
        const y = height - inequalityHistory[i] * height; // Gini is already [0-1]
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      
      // Draw legend
      ctx.font = '12px Arial';
      ctx.fillStyle = 'rgba(255, 119, 255, 0.8)';
      ctx.fillText('Utility', 10, 15);
      
      ctx.fillStyle = 'rgba(119, 255, 255, 0.8)';
      ctx.fillText('Inequality', 70, 15);
    }
    
    // Helper function to convert 3D position to screen position
    function toScreenPosition(obj, camera, renderer) {
      const vector = new THREE.Vector3();
      obj.getWorldPosition(vector);
      
      vector.project(camera);
      
      const widthHalf = renderer.domElement.width / 2;
      const heightHalf = renderer.domElement.height / 2;
      
      return {
        x: (vector.x * widthHalf) + widthHalf,
        y: -(vector.y * heightHalf) + heightHalf
      };
    }
    
    // Simulation step - process transfers for one iteration
    function simulationStep() {
      if (params.isPaused) return;
      
      // Increment iteration counter
      params.iterationCount++;
      
      // Process potential transfers for each connection
      for (let i = 0; i < params.simulationSpeed; i++) {
        // Choose a random connection
        const connIdx = Math.floor(Math.random() * connections.length);
        const conn = connections[connIdx];
        
        const giver = agents[conn.from];
        const receiver = agents[conn.to];
        
        // Check whether transfer should happen
        const giverMarginalUtility = calculateMarginalUtility(giver.consumption);
        const receiverMarginalUtility = calculateMarginalUtility(receiver.consumption);
        
        // Transfer happens if: giver's marginal utility * alpha < receiver's marginal utility
        // And if giver is wealthier than receiver
        if (giverMarginalUtility * conn.strength < receiverMarginalUtility && 
            giver.consumption > receiver.consumption) {
            
          // Calculate optimal transfer amount
          const transferAmount = (giver.consumption - receiver.consumption) * 0.1 * conn.strength;
          
          // Apply transfer if significant
          if (transferAmount > 0.05 && transferAmount < giver.consumption * 0.5) {
            // Update consumptions
            giver.consumption -= transferAmount;
            receiver.consumption += transferAmount;
            
            // Update utilities
            giver.utility = calculateUtility(giver.consumption);
            receiver.utility = calculateUtility(receiver.consumption);
            
            // Track transfer activity
            giver.transferCount = (giver.transferCount || 0) + 1;
            receiver.transferCount = (receiver.transferCount || 0) + 1;
            
            // Update colors
            updateAgentAppearance(giver);
            updateAgentAppearance(receiver);
            
            // Create transfer visualization
            createTransferVisualization(giver, receiver, transferAmount);
            
            // Increment transfer counter
            params.transferCount++;
            
            // Record when the agent was last updated
            giver.lastUpdated = params.iterationCount;
            receiver.lastUpdated = params.iterationCount;
          }
        }
      }
      
      // Update stats every 10 iterations
      if (params.iterationCount % 10 === 0) {
        updateStats();
      }
      
      // Update colors in transfers mode every 30 iterations
      if (displayParams.colorMode === 'transfers' && params.iterationCount % 30 === 0) {
        updateAgentColors();
      }
    }
    
    // Update agent appearance based on utility
    function updateAgentAppearance(agent) {
      // Apply base scale
      const baseScale = displayParams.nodeSize;
      
      // Additional utility-based scaling
      const utility = agent.utility;
      const normalizedUtility = Math.min(1, utility / 2);
      const utilityScale = 0.8 + normalizedUtility * 0.4;
      
      // Set final scale
      const finalScale = baseScale * utilityScale;
      agent.mesh.scale.set(finalScale, finalScale, finalScale);
      
      // Update color and emoji based on display mode
      if (displayParams.colorMode === 'utility') {
        // Color based on utility level
        let color;
        if (normalizedUtility > 0.66) {
          color = highUtilityColor;
        } else if (normalizedUtility > 0.33) {
          color = medUtilityColor;
        } else {
          color = lowUtilityColor;
        }
        
        agent.mesh.material.color.copy(color);
        
        // Update emoji
        if (agent.emojiElement) {
          agent.emojiElement.textContent = normalizedUtility > 0.66 ? '😊' : normalizedUtility > 0.33 ? '😐' : '😟';
        }
      }
    }
    
    // Update emoji positions
    function updateEmojiPositions() {
      for (const agent of agents) {
        if (agent.emojiElement) {
          const screenPos = toScreenPosition(agent.mesh, camera, renderer);
          agent.emojiElement.style.left = (screenPos.x - 12) + 'px';
          agent.emojiElement.style.top = (screenPos.y - 12) + 'px';
          
          // Show/hide based on camera distance and settings
          const distance = camera.position.distanceTo(agent.mesh.position);
          agent.emojiElement.style.display = 
            (displayParams.showEmojis && distance < 80) ? 'block' : 'none';
          
          // Highlight recently updated agents
          const timeSinceUpdate = params.iterationCount - agent.lastUpdated;
          if (timeSinceUpdate < 3) {
            agent.emojiElement.style.textShadow = '0 0 5px white';
          } else {
            agent.emojiElement.style.textShadow = '0 0 3px black';
          }
        }
      }
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Simulation step
      simulationStep();
      
      // Update transfer particles
      updateTransferParticles();
      
      // Update emoji positions
      updateEmojiPositions();
      
      // Render scene
      renderer.render(scene, camera);
      controls.update();
    }
    
    // Start everything
    init();
    animate();
  </script>
</body>
</html>
