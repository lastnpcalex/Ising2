<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Altruism Network Simulation</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: #000; 
      font-family: Arial, sans-serif; 
      color: #fff;
    }
    #info { 
      position: absolute; 
      bottom: 10px; 
      left: 10px; 
      color: white; 
      z-index: 100; 
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #simulationStats {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      max-width: 300px;
    }
    #simulationControls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 1000;
    }
    #simulationControls button {
      background: #4a5fa3;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 5px;
      border-radius: 3px;
      cursor: pointer;
    }
    #simulationControls button:hover {
      background: #677bc4;
    }
    #utilityGraph {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    canvas {
      display: block;
    }
    .smile-1 {
      position: absolute;
      font-size: 24px;
      color: white;
      text-shadow: 0 0 3px black;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div id="info">Dynamic Altruism Network Simulation — drag to rotate, scroll to zoom</div>
  
  <div id="simulationStats">
    <h3>Simulation Statistics</h3>
    <div id="iterationCount">Iteration: 0</div>
    <div id="avgUtility">Average Utility: 0</div>
    <div id="transferCount">Transfers: 0</div>
    <div id="inequalityMeasure">Consumption Gini: 0</div>
  </div>
  
  <div id="simulationControls">
    <h3>Simulation Controls</h3>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <button id="shockBtn">Add Income Shock</button>
    <div>
      <label for="simSpeedSlider">Simulation Speed:</label>
      <input type="range" id="simSpeedSlider" min="1" max="20" value="5">
    </div>
    <div>
      <label for="altruismStrength">Altruism Strength:</label>
      <input type="range" id="altruismStrength" min="0.1" max="2" step="0.1" value="1">
    </div>
    <div>
      <label for="incomeInequalitySlider">Income Inequality:</label>
      <input type="range" id="incomeInequalitySlider" min="0.1" max="3" step="0.1" value="1">
    </div>
  </div>
  
  <div id="utilityGraph">
    <canvas id="graphCanvas" width="300" height="150"></canvas>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Global variables
    let scene, camera, renderer, controls;
    let agents = [];
    let connections = [];
    let activeTransfers = [];
    let utilityHistory = [];
    let inequalityHistory = [];
    let transferParticles = [];
    
    // Simulation parameters
    let params = {
      numAgents: 30,
      altruismStrength: 1.0,
      incomeInequality: 1.0,
      simulationSpeed: 5,
      iterationCount: 0,
      transferCount: 0,
      isPaused: false
    };
    
    // Colors
    const highUtilityColor = new THREE.Color(0xff77ff);
    const medUtilityColor = new THREE.Color(0xffff77);
    const lowUtilityColor = new THREE.Color(0x77ffff);
    
    // Initialize scene
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111133);
      
      // Setup camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 50);
      
      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 1, 1);
      scene.add(directionalLight);
      
      // Initialize UI elements
      setupUIControls();
      
      // Create agents and connections
      createAgentsAndConnections();
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Setup UI controls
    function setupUIControls() {
      // Pause button
      document.getElementById('pauseBtn').addEventListener('click', () => {
        params.isPaused = !params.isPaused;
        document.getElementById('pauseBtn').textContent = params.isPaused ? 'Resume' : 'Pause';
      });
      
      // Reset button
      document.getElementById('resetBtn').addEventListener('click', () => {
        resetSimulation();
      });
      
      // Add income shock
      document.getElementById('shockBtn').addEventListener('click', () => {
        addIncomeShock();
      });
      
      // Speed slider
      document.getElementById('simSpeedSlider').addEventListener('input', (e) => {
        params.simulationSpeed = parseInt(e.target.value);
      });
      
      // Altruism strength slider
      document.getElementById('altruismStrength').addEventListener('input', (e) => {
        params.altruismStrength = parseFloat(e.target.value);
        updateConnectionStrengths();
      });
      
      // Income inequality slider
      document.getElementById('incomeInequalitySlider').addEventListener('input', (e) => {
        params.incomeInequality = parseFloat(e.target.value);
      });
    }
    
    // Update connection strengths when altruism parameter changes
    function updateConnectionStrengths() {
      connections.forEach(conn => {
        // Keep the random component but update the base strength
        conn.strength = params.altruismStrength * conn.randomFactor;
      });
    }
    
    // Generate agent incomes with controlled inequality
    function generateIncomes(count, inequalityFactor) {
      const incomes = [];
      
      if (inequalityFactor <= 1) {
        // Close to uniform distribution
        for (let i = 0; i < count; i++) {
          incomes.push(2 + Math.random() * 8); // range [2-10]
        }
      } else {
        // Power law distribution
        const exponent = 1 + inequalityFactor * 0.5;
        
        for (let i = 0; i < count; i++) {
          const r = Math.random();
          const x = Math.pow(r, -1/exponent);
          incomes.push(1 + x * 19);
        }
      }
      
      return incomes;
    }
    
    // Calculate utility given a consumption level
    function calculateUtility(consumption) {
      // CARA utility function: (1 - e^(-α*c))/α
      const alpha = 0.5;
      return (1 - Math.exp(-alpha * consumption)) / alpha;
    }
    
    // Calculate marginal utility
    function calculateMarginalUtility(consumption) {
      const alpha = 0.5;
      return Math.exp(-alpha * consumption);
    }
    
    // Create agents and connections
    function createAgentsAndConnections() {
      // Clear existing objects
      clearScene();
      
      // Generate incomes
      const incomes = generateIncomes(params.numAgents, params.incomeInequality);
      
      // Create agents
      for (let i = 0; i < params.numAgents; i++) {
        // Position agents in a circle with some randomness
        const angle = (i / params.numAgents) * Math.PI * 2;
        const radius = 15 + (Math.random() - 0.5) * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = (Math.random() - 0.5) * 5;
        
        // Create agent geometry
        const geometry = new THREE.SphereGeometry(1, 16, 16);
        
        // Color based on income
        const utility = calculateUtility(incomes[i]);
        const normalizedUtility = Math.min(1, utility / 2);
        const color = new THREE.Color();
        
        if (normalizedUtility > 0.6) {
          color.copy(highUtilityColor);
        } else if (normalizedUtility > 0.3) {
          color.copy(medUtilityColor);
        } else {
          color.copy(lowUtilityColor);
        }
        
        const material = new THREE.MeshPhongMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        scene.add(mesh);
        
        // Create label to show income
        const smileElement = document.createElement('div');
        smileElement.className = 'smile-1';
        smileElement.textContent = normalizedUtility > 0.6 ? ':)' : normalizedUtility > 0.3 ? ':|' : ':(';
        smileElement.style.display = 'none'; // Hide initially, will be positioned in update
        document.body.appendChild(smileElement);
        
        // Store agent data
        agents.push({
          mesh: mesh,
          income: incomes[i],
          consumption: incomes[i],
          utility: utility,
          position: new THREE.Vector3(x, y, z),
          smileElement: smileElement,
          lastUpdated: 0
        });
      }
      
      // Create connections between agents
      createConnections();
      
      // Initialize history arrays
      utilityHistory = [];
      inequalityHistory = [];
      
      // Reset stats
      params.iterationCount = 0;
      params.transferCount = 0;
      
      updateStats();
    }
    
    // Create connections between agents
    function createConnections() {
      connections = [];
      
      for (let i = 0; i < agents.length; i++) {
        // Connect to neighbors with some probability
        for (let j = 0; j < agents.length; j++) {
          if (i !== j) {
            const distance = agents[i].position.distanceTo(agents[j].position);
            // Higher probability for closer agents
            const probability = 0.3 * (1 / (1 + distance * 0.05));
            
            if (Math.random() < probability) {
              createConnection(i, j);
            }
          }
        }
        
        // Ensure each agent has at least one connection
        if (!connections.some(c => c.from === i || c.to === i)) {
          // Connect to the closest agent
          let closestIdx = -1;
          let minDist = Infinity;
          
          for (let j = 0; j < agents.length; j++) {
            if (i !== j) {
              const distance = agents[i].position.distanceTo(agents[j].position);
              if (distance < minDist) {
                minDist = distance;
                closestIdx = j;
              }
            }
          }
          
          if (closestIdx >= 0) {
            createConnection(i, closestIdx);
          }
        }
      }
    }
    
    // Create a connection between two agents
    function createConnection(i, j) {
      const points = [
        agents[i].position,
        agents[j].position
      ];
      
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x88aaff,
        transparent: true,
        opacity: 0.4
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      
      // Random factor for connection strength
      const randomFactor = 0.8 + Math.random() * 0.4;
      
      connections.push({
        from: i,
        to: j,
        strength: params.altruismStrength * randomFactor,
        randomFactor: randomFactor, // Store for updates
        object: line
      });
    }
    
    // Create a transfer visualization
    function createTransferVisualization(fromAgent, toAgent, amount) {
      // Create a small sphere representing the transfer
      const geometry = new THREE.SphereGeometry(0.2, 8, 8);
      const material = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        transparent: true,
        opacity: 0.8
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      
      // Start at the giving agent
      mesh.position.copy(fromAgent.position);
      scene.add(mesh);
      
      // Store the transfer particle data
      transferParticles.push({
        mesh: mesh,
        from: fromAgent,
        to: toAgent,
        amount: amount,
        progress: 0,
        speed: 0.02 + Math.random() * 0.02
      });
      
      return mesh;
    }
    
    // Update transfer particles
    function updateTransferParticles() {
      // Update existing particles
      for (let i = transferParticles.length - 1; i >= 0; i--) {
        const particle = transferParticles[i];
        
        // Update progress
        particle.progress += particle.speed;
        
        if (particle.progress >= 1) {
          // Remove completed particles
          scene.remove(particle.mesh);
          transferParticles.splice(i, 1);
        } else {
          // Interpolate position
          const newPos = new THREE.Vector3().lerpVectors(
            particle.from.position,
            particle.to.position,
            particle.progress
          );
          
          // Add a small arc to the path
          const mid = new THREE.Vector3().lerpVectors(
            particle.from.position,
            particle.to.position,
            0.5
          );
          
          const up = new THREE.Vector3(0, 0, 1);
          const dir = new THREE.Vector3().subVectors(particle.to.position, particle.from.position);
          if (Math.abs(dir.dot(up)) > 0.9) up.set(1, 0, 0);
          
          const arcHeight = particle.from.position.distanceTo(particle.to.position) * 0.2;
          const normal = new THREE.Vector3().crossVectors(dir, up).normalize();
          
          // Parabolic arc
          const arcOffset = Math.sin(particle.progress * Math.PI) * arcHeight;
          newPos.addScaledVector(normal, arcOffset);
          
          particle.mesh.position.copy(newPos);
          
          // Scale based on amount
          const scale = 0.2 + particle.amount * 0.05;
          particle.mesh.scale.set(scale, scale, scale);
          
          // Pulse effect
          const pulse = 0.8 + 0.2 * Math.sin(particle.progress * Math.PI * 4);
          particle.mesh.scale.multiplyScalar(pulse);
        }
      }
    }
    
    // Clear scene
    function clearScene() {
      // Remove agents
      agents.forEach(agent => {
        scene.remove(agent.mesh);
        if (agent.smileElement) {
          document.body.removeChild(agent.smileElement);
        }
      });
      
      // Remove connections
      connections.forEach(connection => {
        scene.remove(connection.object);
      });
      
      // Remove transfer particles
      transferParticles.forEach(particle => {
        scene.remove(particle.mesh);
      });
      
      agents = [];
      connections = [];
      activeTransfers = [];
      transferParticles = [];
    }
    
    // Reset simulation
    function resetSimulation() {
      createAgentsAndConnections();
    }
    
    // Add an income shock to the system
    function addIncomeShock() {
      // Shock a random agent or the richest agent
      let targetIdx;
      const shockType = Math.random();
      
      if (shockType < 0.5) {
        // Random agent
        targetIdx = Math.floor(Math.random() * agents.length);
      } else {
        // Find the richest agent
        let maxIncome = -Infinity;
        let richestIdx = 0;
        
        for (let i = 0; i < agents.length; i++) {
          if (agents[i].income > maxIncome) {
            maxIncome = agents[i].income;
            richestIdx = i;
          }
        }
        
        targetIdx = richestIdx;
      }
      
      // Apply shock - either positive or negative
      const direction = Math.random() < 0.7 ? 1 : -1; // 70% chance of positive shock
      const magnitude = agents[targetIdx].income * (0.3 + Math.random() * 0.5); // 30-80% change
      
      // Apply the shock
      agents[targetIdx].income += direction * magnitude;
      agents[targetIdx].income = Math.max(1, agents[targetIdx].income); // Ensure minimum income
      
      // Update consumption as well (immediate effect)
      agents[targetIdx].consumption += direction * magnitude;
      agents[targetIdx].consumption = Math.max(1, agents[targetIdx].consumption);
      
      // Update utility
      agents[targetIdx].utility = calculateUtility(agents[targetIdx].consumption);
      
      // Visual indication of the shock
      const agent = agents[targetIdx];
      
      // Briefly make the agent larger
      const originalScale = agent.mesh.scale.x;
      agent.mesh.scale.set(originalScale * 2, originalScale * 2, originalScale * 2);
      
      // Animate back to normal size
      setTimeout(() => {
        agent.mesh.scale.set(originalScale, originalScale, originalScale);
      }, 500);
      
      // Show a message
      const shockMsg = document.createElement('div');
      shockMsg.style.position = 'absolute';
      shockMsg.style.color = direction > 0 ? 'lime' : 'red';
      shockMsg.style.fontSize = '16px';
      shockMsg.style.fontWeight = 'bold';
      shockMsg.style.textShadow = '0 0 3px black';
      shockMsg.textContent = direction > 0 ? '+' + magnitude.toFixed(1) : magnitude.toFixed(1);
      
      // Position near the agent
      const screenPos = toScreenPosition(agent.mesh, camera, renderer);
      shockMsg.style.left = screenPos.x + 'px';
      shockMsg.style.top = (screenPos.y - 30) + 'px';
      
      document.body.appendChild(shockMsg);
      
      // Remove after animation
      setTimeout(() => {
        shockMsg.style.transition = 'opacity 1s';
        shockMsg.style.opacity = '0';
      }, 1000);
      
      setTimeout(() => {
        document.body.removeChild(shockMsg);
      }, 2000);
      
      // Update stats
      updateStats();
    }
    
    // Calculate Gini coefficient (inequality measure)
    function calculateGini(values) {
      // Sort values in ascending order
      const sortedValues = [...values].sort((a, b) => a - b);
      const n = sortedValues.length;
      
      if (n === 0) return 0;
      
      let sumOfAbsoluteDifferences = 0;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          sumOfAbsoluteDifferences += Math.abs(sortedValues[i] - sortedValues[j]);
        }
      }
      
      // Gini formula
      return sumOfAbsoluteDifferences / (2 * n * n * sortedValues.reduce((a, b) => a + b, 0) / n);
    }
    
    // Update simulation statistics
    function updateStats() {
      // Calculate average utility
      let totalUtility = 0;
      for (const agent of agents) {
        totalUtility += agent.utility;
      }
      const avgUtility = totalUtility / agents.length;
      
      // Calculate consumption inequality (Gini coefficient)
      const consumptions = agents.map(a => a.consumption);
      const giniCoefficient = calculateGini(consumptions);
      
      // Update history arrays
      utilityHistory.push(avgUtility);
      inequalityHistory.push(giniCoefficient);
      
      // Limit history length
      const maxHistory = 100;
      if (utilityHistory.length > maxHistory) {
        utilityHistory.shift();
        inequalityHistory.shift();
      }
      
      // Update UI
      document.getElementById('iterationCount').textContent = `Iteration: ${params.iterationCount}`;
      document.getElementById('avgUtility').textContent = `Average Utility: ${avgUtility.toFixed(3)}`;
      document.getElementById('transferCount').textContent = `Transfers: ${params.transferCount}`;
      document.getElementById('inequalityMeasure').textContent = `Consumption Gini: ${giniCoefficient.toFixed(3)}`;
      
      // Draw graph
      drawUtilityGraph();
    }
    
    // Draw utility graph
    function drawUtilityGraph() {
      const canvas = document.getElementById('graphCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, width, height);
      
      // Draw grid lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;
      
      // Horizontal grid lines
      for (let i = 0; i <= 5; i++) {
        const y = height - (i / 5) * height;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // Vertical grid lines
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      // No data to draw
      if (utilityHistory.length < 2) return;
      
      // Find max utility for scaling
      const maxUtility = Math.max(...utilityHistory, 2);
      
      // Draw utility history
      ctx.strokeStyle = 'rgba(255, 119, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < utilityHistory.length; i++) {
        const x = (i / (utilityHistory.length - 1)) * width;
        const y = height - (utilityHistory[i] / maxUtility) * height;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      
      // Draw inequality history
      ctx.strokeStyle = 'rgba(119, 255, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < inequalityHistory.length; i++) {
        const x = (i / (inequalityHistory.length - 1)) * width;
        const y = height - inequalityHistory[i] * height; // Gini is already [0-1]
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      
      // Draw legend
      ctx.font = '12px Arial';
      ctx.fillStyle = 'rgba(255, 119, 255, 0.8)';
      ctx.fillText('Utility', 10, 15);
      
      ctx.fillStyle = 'rgba(119, 255, 255, 0.8)';
      ctx.fillText('Inequality', 70, 15);
    }
    
    // Helper function to convert 3D position to screen position
    function toScreenPosition(obj, camera, renderer) {
      const vector = new THREE.Vector3();
      obj.getWorldPosition(vector);
      
      vector.project(camera);
      
      const widthHalf = renderer.domElement.width / 2;
      const heightHalf = renderer.domElement.height / 2;
      
      return {
        x: (vector.x * widthHalf) + widthHalf,
        y: -(vector.y * heightHalf) + heightHalf
      };
    }
    
    // Simulation step - process transfers for one iteration
    function simulationStep() {
      if (params.isPaused) return;
      
      // Increment iteration counter
      params.iterationCount++;
      
      // Process potential transfers for each connection
      for (let i = 0; i < params.simulationSpeed; i++) {
        // Choose a random connection
        const connIdx = Math.floor(Math.random() * connections.length);
        const conn = connections[connIdx];
        
        const giver = agents[conn.from];
        const receiver = agents[conn.to];
        
        // Check whether transfer should happen
        const giverMarginalUtility = calculateMarginalUtility(giver.consumption);
        const receiverMarginalUtility = calculateMarginalUtility(receiver.consumption);
        
        // Transfer happens if: giver's marginal utility * alpha < receiver's marginal utility
        // And if giver is wealthier than receiver
        if (giverMarginalUtility * conn.strength < receiverMarginalUtility && 
            giver.consumption > receiver.consumption) {
            
          // Calculate optimal transfer amount
          // This is an approximation - in a more complex simulation we would solve
          // the equation that equalizes the marginal utilities
          const transferAmount = (giver.consumption - receiver.consumption) * 0.1 * conn.strength;
          
          // Apply transfer if significant
          if (transferAmount > 0.05 && transferAmount < giver.consumption * 0.5) {
            // Update consumptions
            giver.consumption -= transferAmount;
            receiver.consumption += transferAmount;
            
            // Update utilities
            giver.utility = calculateUtility(giver.consumption);
            receiver.utility = calculateUtility(receiver.consumption);
            
            // Update colors
            updateAgentAppearance(giver);
            updateAgentAppearance(receiver);
            
            // Create transfer visualization
            createTransferVisualization(giver, receiver, transferAmount);
            
            // Increment transfer counter
            params.transferCount++;
            
            // Record when the agent was last updated
            giver.lastUpdated = params.iterationCount;
            receiver.lastUpdated = params.iterationCount;
          }
        }
      }
      
      // Update stats every 10 iterations
      if (params.iterationCount % 10 === 0) {
        updateStats();
      }
    }
    
    // Update agent appearance based on utility
    function updateAgentAppearance(agent) {
      const utility = agent.utility;
      const normalizedUtility = Math.min(1, utility / 2);
      
      // Update color
      let color;
      if (normalizedUtility > 0.6) {
        color = highUtilityColor;
      } else if (normalizedUtility > 0.3) {
        color = medUtilityColor;
      } else {
        color = lowUtilityColor;
      }
      
      agent.mesh.material.color.copy(color);
      
      // Update size based on utility
      const scale = 0.8 + normalizedUtility * 0.4;
      agent.mesh.scale.set(scale, scale, scale);
      
      // Update smile
      if (agent.smileElement) {
        agent.smileElement.textContent = normalizedUtility > 0.6 ? ':)' : normalizedUtility > 0.3 ? ':|' : ':(';
      }
    }
    
    // Update smile positions
    function updateSmilePositions() {
      for (const agent of agents) {
        if (agent.smileElement) {
          const screenPos = toScreenPosition(agent.mesh, camera, renderer);
          agent.smileElement.style.left = (screenPos.x - 12) + 'px';
          agent.smileElement.style.top = (screenPos.y - 12) + 'px';
          
          // Show/hide based on camera distance
          const distance = camera.position.distanceTo(agent.mesh.position);
          agent.smileElement.style.display = distance < 50 ? 'block' : 'none';
          
          // Highlight recently updated agents
          const timeSinceUpdate = params.iterationCount - agent.lastUpdated;
          if (timeSinceUpdate < 3) {
            agent.smileElement.style.textShadow = '0 0 5px white';
          } else {
            agent.smileElement.style.textShadow = '0 0 3px black';
          }
        }
      }
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Simulation step
      simulationStep();
      
      // Update transfer particles
      updateTransferParticles();
      
      // Update emoji positions
      updateSmilePositions();
      
      // Render scene
      renderer.render(scene, camera);
      controls.update();
    }
    
    // Start everything
    init();
    animate();
  </script>
</body>
</html>
