<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8" />
    <title>Vaporwave 3D Ising Model Simulator</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        z-index: 100;
        font-family: sans-serif;
      }
      #magGraph {
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 200;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #444;
      }
      /* Vaporwave-styled Modal Pop-up */
      #phaseModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(20, 20, 20, 0.7);
        backdrop-filter: blur(5px);
        z-index: 300;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #phaseModalContent {
        background: linear-gradient(135deg, rgba(255,105,180,0.8), rgba(138,43,226,0.8));
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 15px;
        box-shadow: 0 0 15px rgba(255,105,180,0.8);
        padding: 20px 30px;
        text-align: center;
        font-family: 'Courier New', Courier, monospace;
        color: #fff;
      }
      #phaseModalButton {
        background: rgba(255,255,255,0.3);
        border: none;
        border-radius: 5px;
        color: #fff;
        padding: 10px 20px;
        font-size: 16px;
        margin-top: 15px;
        cursor: pointer;
        transition: background 0.3s ease;
      }
      #phaseModalButton:hover {
        background: rgba(255,255,255,0.5);
      }
    </style>

    <!-- Three.js + OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <!-- dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
  </head>
  <body>
    <div id="info">Vaporwave 3D Ising Model â€” drag to rotate, scroll to zoom</div>
    <canvas id="magGraph" width="300" height="100"></canvas>
    <!-- Vaporwave-styled Modal Pop-up -->
    <div id="phaseModal">
      <div id="phaseModalContent">
        <p id="phaseModalText"></p>
        <button id="phaseModalButton">OK</button>
      </div>
    </div>

    <script>
      // -------------------------------------------------
      // Global Variables
      // -------------------------------------------------
      let scene, camera, renderer, controls;
      let nodes = []; // Each node: { mesh, spin, basePos, pos, neighbors }
      let edgeLines = []; // Each edge: { i, j, line }
      let simulationSpeed = 100; // Metropolis steps per frame

      // Off-screen canvas for background gradient
      let bgCanvas, bgCtx, bgTexture;

      // Magnetization graph tracking
      const maxHistoryLength = 200;
      let magnetizationHistory = [];
      let smoothedMag = 0; // For smooth background transitions

      // Graph canvas
      let graphCanvas, graphCtx;

      // Global variable for phase pop-up
      let currentPhase = null;

      // Texture maps for smiley overlays
      let textureMap2 = {}; // For two-spin: keys "1", "-1"
      let textureMap3 = {}; // For three-spin: keys "1", "0", "-1"

      // -------------------------------------------------
      // Helper: Create a text texture from a canvas
      // -------------------------------------------------
    function createTextTexture(text, fontSize, textColor) {
  const canvas = document.createElement("canvas");
  canvas.width = 256;  // Increased resolution
  canvas.height = 256;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.font = fontSize + "px Arial";
  ctx.fillStyle = textColor;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
  const texture = new THREE.CanvasTexture(canvas);
  texture.magFilter = THREE.LinearFilter; // Smoother scaling
  texture.minFilter = THREE.LinearFilter;
  texture.needsUpdate = true;
  return texture;
}


      // -------------------------------------------------
      // Initialize Textures
      // -------------------------------------------------
      function initTextures() {
        // For two-spin system: smiley faces in black.
        textureMap2["1"] = createTextTexture(":)", 32, "#000000");
        textureMap2["-1"] = createTextTexture(":(", 32, "#000000");
        // For three-spin system: all states in black.
        textureMap3["1"] = createTextTexture(":)", 32, "#000000");
        textureMap3["0"] = createTextTexture(":|", 32, "#000000");  // Changed to black
        textureMap3["-1"] = createTextTexture(":(", 32, "#000000");
      }

      // -------------------------------------------------
      // Simulation Parameters
      // -------------------------------------------------
      const params = {
        coupling: 1.0,
        temperature: 1.0,
        field: 0.0,
        numNodes: 1500,
        spinBias: 0.0,
        neighborsCount: 4,
        density: 2.5,
        showConnectors: true,
        threeSpin: false, // Toggle for 2-spin vs. 3-spin
        showFaces: true,  // Toggle for showing/hiding face sprites
        reinitialize: function() {
          clearScene();
          createNodesAndEdges();
        }
      };

      // Node range
      const MIN_NODES = 10;
      const MAX_NODES = 3000;

      // Colors for sphere materials (for spin states)
      const spinColorPositive = new THREE.Color(0xff77ff); // Neon pink
      const spinColorNegative = new THREE.Color(0x77ffff); // Neon cyan
      // For three-spin system, define a neutral color (light gray)
      const spinColorNeutral = new THREE.Color(0x666666);

      // Background gradient colors
      const nightTop    = new THREE.Color("#0a0c37");
      const nightBottom = new THREE.Color("#375971");
      const dayTop      = new THREE.Color("#ff61c6");
      const dayBottom   = new THREE.Color("#ff9900");

      // -------------------------------------------------
      // Create a Node (sphere with overlay sprite)
      // -------------------------------------------------
      function createNode(spin, basePos) {
        const geometry = new THREE.SphereGeometry(0.5, 16, 16);
        let baseColor;
        if (params.threeSpin) {
          if (spin === 1) baseColor = spinColorPositive;
          else if (spin === -1) baseColor = spinColorNegative;
          else baseColor = spinColorNeutral;
        } else {
          baseColor = spin > 0 ? spinColorPositive : spinColorNegative;
        }
        const material = new THREE.MeshPhongMaterial({
          color: baseColor,
          emissive: 0x111111
        });
        const mesh = new THREE.Mesh(geometry, material);

        // Select the appropriate texture for the overlay
        let texture;
        if (params.threeSpin) {
          texture = textureMap3[spin.toString()];
        } else {
          texture = textureMap2[spin.toString()];
        }
        // Create the sprite
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthTest: true,
          depthWrite: false
        });
     const sprite = new THREE.Sprite(spriteMaterial);
sprite.scale.set(5, 5, 1); // Adjusted scale for higher resolution texture
// Position the sprite slightly in front of the sphere surface.
sprite.position.set(0, 0, 0.01);
mesh.add(sprite);

        mesh.position.copy(basePos);
        return mesh;
      }

// Update Sprite offset to make it visible.

function updateSpriteOffsets() {
  nodes.forEach(node => {
    const sprite = node.mesh.children[0];
    // Get the sphere's world position.
    const worldPos = new THREE.Vector3();
    node.mesh.getWorldPosition(worldPos);
    // Compute direction from sphere to camera.
    const offsetDir = new THREE.Vector3().subVectors(camera.position, worldPos).normalize();
    // Adjust this value until you see the sprite.
    const offsetDistance = 0.6;
    sprite.position.copy(offsetDir.multiplyScalar(offsetDistance));
  });
}


      // -------------------------------------------------
      // Initialization
      // -------------------------------------------------
      function init() {
        initTextures();
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 40);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        bgCanvas = document.createElement("canvas");
        bgCanvas.width = 128;
        bgCanvas.height = 128;
        bgCtx = bgCanvas.getContext("2d");
        bgTexture = new THREE.CanvasTexture(bgCanvas);
        scene.background = bgTexture;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);

        createNodesAndEdges();

        graphCanvas = document.getElementById("magGraph");
        graphCtx = graphCanvas.getContext("2d");

        createGUI();

        window.addEventListener("resize", onWindowResize, false);

        document.getElementById("phaseModalButton").addEventListener("click", () => {
          document.getElementById("phaseModal").style.display = "none";
        });
        window.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            document.getElementById("phaseModal").style.display = "none";
          }
        });

        animate();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // -------------------------------------------------
      // GUI (with tooltips)
      // -------------------------------------------------
      function createGUI() {
        const gui = new dat.GUI();

        const c1 = gui.add(params, "coupling", -5, 5, 0.1).name("Coupling (J)");
        setTooltip(c1, "Interaction strength between spins. Positive favors alignment.");

        const c2 = gui.add(params, "temperature", 0.1, 10, 0.1).name("Temperature (T)");
        setTooltip(c2, "Thermal fluctuations. Lower values lead to stronger magnetization.");

        const c3 = gui.add(params, "field", -1, 1, 0.01).name("Field (H)");
        setTooltip(c3, "External magnetic field (range: -1 to 1).");

        const c4 = gui.add(params, "spinBias", -1, 1, 0.1).name("Spin Bias");
        setTooltip(c4, "Bias for initial spin assignment (for 2-spin).");

        const c5 = gui.add(params, "neighborsCount", 1, 6, 1).name("Neighbors");
        setTooltip(c5, "Number of nearest neighbors (on reinit).");

        const c6 = gui.add(params, "numNodes", MIN_NODES, MAX_NODES, 1).name("Nodes");
        setTooltip(c6, "Total number of nodes (on reinit).");

        const c7 = gui.add(params, "density", 0.1, 3.0, 0.1).name("Density");
        setTooltip(c7, "Scales node positions without altering spins or neighbors.");
        c7.onChange(updateDensity);

        const c8 = gui.add(params, "showConnectors").name("Show Connectors");
        setTooltip(c8, "Toggle visibility of connector lines.");

        const c9 = gui.add(params, "threeSpin").name("3 States");
        setTooltip(c9, "Toggle between 2-spin and 3-spin (adds neutral state) systems.");
        c9.onChange(() => { params.reinitialize(); });

        // --- New Toggle for Face Sprites ---
        const c10 = gui.add(params, "showFaces").name("Show Faces");
        setTooltip(c10, "Toggle the visibility of the face sprites.");

        const c11 = gui.add(params, "reinitialize").name("Reinitialize");
        setTooltip(c11, "Rebuild simulation with current parameters.");
      }

      function setTooltip(controller, tooltipText) {
        requestAnimationFrame(() => {
          if (controller.__li) {
            controller.__li.title = tooltipText;
          }
        });
      }

      // -------------------------------------------------
      // Create Nodes & Connectors
      // -------------------------------------------------
      function createNodesAndEdges() {
        nodes = [];
        edgeLines.forEach((obj) => scene.remove(obj.line));
        edgeLines = [];

        const cubeSize = 30;
        for (let i = 0; i < params.numNodes; i++) {
          let spin;
          if (params.threeSpin) {
            const r = Math.random();
            if (r < 1/3) spin = -1;
            else if (r < 2/3) spin = 0;
            else spin = 1;
          } else {
            const p = 0.5 + params.spinBias * 0.5;
            spin = Math.random() < p ? 1 : -1;
          }

          const basePos = new THREE.Vector3(
            (Math.random() - 0.5) * cubeSize,
            (Math.random() - 0.5) * cubeSize,
            (Math.random() - 0.5) * cubeSize
          );

          const mesh = createNode(spin, basePos);
          scene.add(mesh);

          nodes.push({
            mesh: mesh,
            spin: spin,
            basePos: basePos,
            pos: basePos.clone(),
            neighbors: []
          });
        }

        // Build neighbor lists (based on basePos distances)
        for (let i = 0; i < nodes.length; i++) {
          let distances = [];
          for (let j = 0; j < nodes.length; j++) {
            if (i === j) continue;
            const d = nodes[i].basePos.distanceTo(nodes[j].basePos);
            distances.push({ index: j, dist: d });
          }
          distances.sort((a, b) => a.dist - b.dist);
          nodes[i].neighbors = distances.slice(0, params.neighborsCount).map(o => o.index);
        }

        // Create connector lines (avoid duplicates)
        let drawnEdges = new Set();
        for (let i = 0; i < nodes.length; i++) {
          for (let j of nodes[i].neighbors) {
            const key = i < j ? i + "_" + j : j + "_" + i;
            if (!drawnEdges.has(key)) {
              drawnEdges.add(key);
              const geometry = new THREE.BufferGeometry().setFromPoints([nodes[i].pos, nodes[j].pos]);
              const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                opacity: 0.5,
                transparent: true
              });
              const line = new THREE.Line(geometry, material);
              scene.add(line);
              edgeLines.push({ i, j, line });
            }
          }
        }
        updateDensity();
      }

      // -------------------------------------------------
      // Update Density (Rescale Positions)
      // -------------------------------------------------
      function updateDensity() {
        nodes.forEach((node) => {
          node.pos.copy(node.basePos).multiplyScalar(params.density);
          node.mesh.position.copy(node.pos);
        });
        edgeLines.forEach((edge) => {
          edge.line.geometry.setFromPoints([nodes[edge.i].pos, nodes[edge.j].pos]);
        });
      }

      // -------------------------------------------------
      // Simulation Step (Metropolis)
      // -------------------------------------------------
      function simulationStep() {
        for (let step = 0; step < simulationSpeed; step++) {
          const i = Math.floor(Math.random() * nodes.length);
          const node = nodes[i];
          const s = node.spin;
          let sumNeighbors = 0;
          node.neighbors.forEach(j => { sumNeighbors += nodes[j].spin; });
          
          if (!params.threeSpin) {
            const deltaE = 2 * s * (params.coupling * sumNeighbors + params.field);
            if (deltaE <= 0 || Math.random() < Math.exp(-deltaE / params.temperature)) {
              node.spin = -s;
              // Update sphere color for two-spin system.
              node.mesh.material.color.copy(node.spin > 0 ? spinColorPositive : spinColorNegative);
              // Update overlay sprite texture.
              const newTexture = textureMap2[node.spin.toString()];
              node.mesh.children[0].material.map = newTexture;
              node.mesh.children[0].material.needsUpdate = true;
            }
          } else {
            const possible = [-1, 0, 1].filter(v => v !== s);
            const candidate = possible[Math.floor(Math.random() * possible.length)];
            const delta = candidate - s;
            const deltaE = -params.coupling * delta * sumNeighbors - params.field * delta;
            if (deltaE <= 0 || Math.random() < Math.exp(-deltaE / params.temperature)) {
              node.spin = candidate;
              // Update sphere color for three-spin system.
              if (node.spin === 1) node.mesh.material.color.copy(spinColorPositive);
              else if (node.spin === -1) node.mesh.material.color.copy(spinColorNegative);
              else node.mesh.material.color.copy(spinColorNeutral);
              // Update overlay sprite texture.
              const newTexture = textureMap3[node.spin.toString()];
              node.mesh.children[0].material.map = newTexture;
              node.mesh.children[0].material.needsUpdate = true;
            }
          }
        }
      }

      // -------------------------------------------------
      // Update Magnetization, Background, Graph, and Phase Detection
      // -------------------------------------------------
      function updateMagnetization() {
        let total = 0;
        nodes.forEach(node => { total += node.spin; });
        const m = total / nodes.length;
        magnetizationHistory.push(m);
        if (magnetizationHistory.length > maxHistoryLength) magnetizationHistory.shift();
        smoothedMag += 0.01 * (m - smoothedMag);
        updateBackgroundGradient(smoothedMag);
        drawGraph();
        detectPhaseChange(smoothedMag);
      }

      // -------------------------------------------------
      // Vaporwave Gradient Background
      // -------------------------------------------------
      function updateBackgroundGradient(mVal) {
        const t = (mVal + 1) / 2;
        const topColor = nightTop.clone().lerp(dayTop, t);
        const bottomColor = nightBottom.clone().lerp(dayBottom, t);
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        const gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
        gradient.addColorStop(0, "#" + topColor.getHexString());
        gradient.addColorStop(1, "#" + bottomColor.getHexString());
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        bgTexture.needsUpdate = true;
      }

      // -------------------------------------------------
      // Draw Magnetization Graph
      // -------------------------------------------------
      function drawGraph() {
        const w = graphCanvas.width, h = graphCanvas.height;
        graphCtx.clearRect(0, 0, w, h);
        graphCtx.strokeStyle = "#fff";
        graphCtx.lineWidth = 1;
        graphCtx.beginPath();
        graphCtx.moveTo(30, 10);
        graphCtx.lineTo(30, 90);
        graphCtx.lineTo(280, 90);
        graphCtx.stroke();
        graphCtx.fillStyle = "#fff";
        graphCtx.font = "10px sans-serif";
        graphCtx.fillText("1", 5, 15);
        graphCtx.fillText("0", 5, 50);
        graphCtx.fillText("-1", 5, 90);
        graphCtx.beginPath();
        graphCtx.strokeStyle = "lime";
        const len = magnetizationHistory.length;
        for (let i = 0; i < len; i++) {
          const x = 30 + (i / (maxHistoryLength - 1)) * (280 - 30);
          const mag = magnetizationHistory[i];
          const y = 90 - ((mag + 1) * 80) / 2;
          if (i === 0) graphCtx.moveTo(x, y);
          else graphCtx.lineTo(x, y);
        }
        graphCtx.stroke();
      }

      // -------------------------------------------------
      // Phase Change Detection & Stylish Pop-up
      // -------------------------------------------------
      function detectPhaseChange(mVal) {
        let newPhase = null;
        if (mVal > 0.7) newPhase = "Positive Ferromagnetic Phase (Bright Future ðŸ˜Ž)";
        else if (mVal < -0.7) newPhase = "Negative Ferromagnetic Phase (Cool Zone ðŸ˜¡)";
        else if (Math.abs(mVal) < 0.3) newPhase = "Disordered Phase Paramagnetic (Neutral Zone ðŸ˜)";
        if (newPhase && newPhase !== currentPhase) {
          currentPhase = newPhase;
          triggerPhasePopup(newPhase);
        }
      }

      function triggerPhasePopup(phaseDescription) {
        const modal = document.getElementById("phaseModal");
        const modalText = document.getElementById("phaseModalText");
        modalText.textContent = "Congratulations! You have entered: " + phaseDescription;
        modal.style.display = "flex";
      }

      // -------------------------------------------------
      // Clear Scene
      // -------------------------------------------------
      function clearScene() {
        nodes.forEach(node => { scene.remove(node.mesh); });
        nodes = [];
        edgeLines.forEach(edge => { scene.remove(edge.line); });
        edgeLines = [];
        magnetizationHistory = [];
      }

      // -------------------------------------------------
      // Animation Loop
      // -------------------------------------------------
      function animate() {
        requestAnimationFrame(animate);
        simulationStep();
        updateMagnetization();
  updateSpriteOffsets(); // Update sprite offsets every frame
        edgeLines.forEach(edge => { edge.line.visible = params.showConnectors; });
        // Toggle sprite (smiley) visibility based on the showFaces parameter.
        nodes.forEach(node => {
          if (node.mesh.children[0]) {
            node.mesh.children[0].visible = params.showFaces;
          }
        });
        controls.update();
        renderer.render(scene, camera);
      }

      // -------------------------------------------------
      // Start
      // -------------------------------------------------
      init();
    </script>
  </body>
</html>
